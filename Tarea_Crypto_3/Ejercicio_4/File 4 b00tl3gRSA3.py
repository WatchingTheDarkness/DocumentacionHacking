from Crypto.Util.number import long_to_bytes, inverse

# Valores del problema
c = 13628753663675835999103566952386643506843582306198662116287259613721988777731409929714285198516185427981324862452367163833500179530664857839397805257009232953980418012997514391403179799635134146088703575337515281211506867297625064657648279076871717590416168315922954719027542808829476948644911499849050455546490212586000577588020398131280684453
n = 24220414837580270003887113919341440204141110073031917972836638473787785345587547612540855397071726418525209185829863502923936755157770416040429826809050553511461437790040383518370669791399096838527532750150779702965184073438191550336852945241807747391773097211534728869107386740682446654992915821828529899660283433467327260428185149425039171297
e = 65537

# Factores primos obtenidos de SageMath
factors = [
    8735621569, 9550965373, 9588798683, 9672804553, 9675116377, 
    9726465641, 10157256413, 10460329591, 10524334529, 10642183661, 
    10993851419, 11106003463, 11213014931, 11554717061, 11979840749, 
    12286506971, 12712238663, 12853091023, 13310471621, 13416923789, 
    13810258307, 13815443947, 13839088897, 14537901041, 14822799419, 
    15141328637, 15524754887, 15693130303, 15694526087, 15955356301, 
    16318724239, 16697823629, 16721086397, 17177141327
]

print(f"‚úÖ N√∫mero de factores primos: {len(factors)}")

# Verificar que el producto de factores sea n
product = 1
for p in factors:
    product *= p

print(f"‚úÖ Producto de factores == n: {product == n}")

if product == n:
    # Calcular œÜ(n) para m√∫ltiples factores
    phi = 1
    for p in factors:
        phi *= (p - 1)
    
    print("üîê Calculando clave privada d...")
    d = inverse(e, phi)
    
    print("üîì Descifrando mensaje...")
    m = pow(c, d, n)
    flag = long_to_bytes(m)
    
    print(f"\nüéØ FLAG: {flag.decode()}")
else:
    print("‚ùå Error: El producto de factores no coincide con n")